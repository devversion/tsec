// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import {ENABLED_RULES} from './rule_groups';
import {Checker} from './third_party/tsetse/checker';
import * as ts from 'typescript';

import {ExemptionList, getExemptionConfigPath, parseExemptionConfig} from './exemption_config';
import {createDiagnosticsReporter} from './report';

/** Check if tsec is invoked in the build mode. */
export function isInBuildMode(cmdArgs: string[]) {
  // --build or -b has to be the first argument
  if (cmdArgs.length && cmdArgs[0].charAt(0) === '-') {
    const optionStart = cmdArgs[0].charAt(1) === '-' ? 2 : 1;
    const firstOption = cmdArgs[0].slice(optionStart);
    return firstOption === 'build' || firstOption === 'b';
  }
  return false;
}

/** Perform security checks on a single project. */
export function performCheck(
    program: ts.Program,
    includePreEmitDiagnostics: boolean = true): ts.Diagnostic[] {
  const diagnostics =
      includePreEmitDiagnostics ? [...ts.getPreEmitDiagnostics(program)] : [];

  let exemptionList: ExemptionList|undefined = undefined;

  const exemptionConfigPath =
      getExemptionConfigPath(program.getCompilerOptions());

  if (exemptionConfigPath) {
    const projExemptionConfigOrErr = parseExemptionConfig(exemptionConfigPath);
    if (projExemptionConfigOrErr instanceof ExemptionList) {
      exemptionList = projExemptionConfigOrErr;
    } else {
      diagnostics.push(...projExemptionConfigOrErr);
    }
  }

  // Create all enabled rules with corresponding exemption list entries.
  const checker = new Checker(program);
  const rules = ENABLED_RULES.map(ruleCtr => {
    const allowlistEntries = [];
    const allowlistEntry = exemptionList?.get(ruleCtr.RULE_NAME);
    if (allowlistEntry) {
      allowlistEntries.push(allowlistEntry);
    }
    return new ruleCtr({allowlistEntries});
  });

  // Register all rules.
  for (const rule of rules) {
    rule.register(checker);
  }

  // Run all enabled checks and collect errors.
  for (const sf of program.getSourceFiles()) {
    // We don't emit errors for delcarations, so might as well skip checking
    // declaration files all together.
    if (sf.isDeclarationFile) continue;
    const tsecErrors = checker.execute(sf).map(
        failure => failure.toDiagnosticWithStringifiedFixes());
    diagnostics.push(...tsecErrors);
  }

  return diagnostics;
}

/** Perform checks on a monorepo. */
export function performBuild(args: string[]): number {
  // This is an internal interface used by the TS compiler.
  interface ParsedBuildCommand {
    buildOptions: ts.BuildOptions;
    watchOptions: ts.WatchOptions|undefined;
    projects: string[];
    errors: ts.Diagnostic[];
  }

  // TypeScript has an API to parse command lines in build mode, but for some
  // reason it's not public. For now we would like to reuse this facility, so
  // we will use type casts to bypass visibility restrictions.
  // TODO(pwng): Replace this hack with our own implementations if this API
  // turns out to be very unstable.
  const parseBuildCommand =
      // tslint:disable-next-line:ban-module-namespace-object-escape
      (ts as unknown as {
        parseBuildCommand: (args: readonly string[]) => ParsedBuildCommand
      }).parseBuildCommand;

  const {buildOptions, projects, errors} = parseBuildCommand(args);
  const reportDiagnostics = createDiagnosticsReporter(buildOptions);

  if (errors.length !== 0) {
    return reportDiagnostics(errors, /*withSummary*/ true);
  }

  if (projects.length === 0) projects.push('.');

  // A hack to invalidate any build info generated by the vanilla tsc to make
  // sure tsec has a chance to build the project even nothing is modified
  // since last build. `ts.version` is readonly so we have to cast its type.
  // TODO(pwng): Add an additional version suffix to reflect the configurations
  // applied in this tsec run.
  // tslint:disable-next-line:ban-module-namespace-object-escape
  (ts as {version: string}).version += '-tsec';

  const nonTsecErrors: ts.Diagnostic[] = [];
  const builderHost = ts.createSolutionBuilderHost(
      ts.sys,
      /*createProgram*/ undefined,
      // Suppress the reporting of pre-emit diagnostics. We will report them
      // with errors together at the end of the build.
      /*reportDiagnostic*/
      diag => {
        nonTsecErrors.push(diag);
      },
      /*reportSolutionBuilderStatus*/ undefined,
      // Suppress the reporting of error summary. We will report it later.
      /*reportErrorSummary*/ () => {},
  );

  const tsecErrors: ts.Diagnostic[] = [];
  // So far, `afterProgramEmitAndDiagnostics` is the only known API that allows
  // us to hook a callback. Therefore, we can only perform security checks
  // after code emission. See b/174168274.
  builderHost.afterProgramEmitAndDiagnostics = (builder) => {
    tsecErrors.push(...performCheck(
        builder.getProgram(),
        /*includePreEmitDiagnostics*/ false));
  };
  const builder = ts.createSolutionBuilder(builderHost, projects, buildOptions);
  buildOptions['clean'] ? builder.clean() : builder.build();

  const freshDate = new Date();
  // Since tsec does checks after code emission, security errors do
  // not prevent JS code from being emitted (if there are no other errors in
  // the TS source file). Therefore, for those TS source files, we need to
  // update their freshness to make sure they will still be built next time.
  // TODO(b/174168274): The ideal solution is to find a better API to insert
  // security check callback.
  for (const error of tsecErrors) {
    const sourceFile = error.file;
    // If `error.source` is undefined, it is not a tsec error.
    if (error.source && sourceFile) {
      builderHost.setModifiedTime(sourceFile.fileName, freshDate);
    }
  }

  return reportDiagnostics(
      [
        ...nonTsecErrors,
        ...tsecErrors,
      ],
      /*withSummary*/ true);
}
